{"version":3,"sources":["index.tsx"],"names":["cytoscape","use","fcose","klay","dagre","div","document","body","appendChild","createElement","args","updateComponent","cy","Streamlit","setComponentValue","$","map","x","events","addEventListener","RENDER_EVENT","event","data","detail","newArgs","JSON","stringify","style","width","height","nodeColor","theme","backgroundColor","background","selector","primaryColor","color","textColor","fontFamily","font","targetArrowColor","lineColor","container","elements","concat","layout","selectionType","userZoomingEnabled","userPanningEnabled","minZoom","maxZoom","on","setFrameHeight","setComponentReady"],"mappings":"oJAAA,0FAaAA,IAAUC,IAAIC,KACdF,IAAUC,IAAIE,KACdH,IAAUC,IAAIG,KAEd,IAAMC,EAAMC,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACzDC,EAAO,GAEX,SAASC,EAAgBC,GACvBC,IAAUC,kBAAkB,CAC1B,MAASF,EAAGG,EAAE,iBAAiBC,KAAI,SAACC,GAAD,OAAYA,EAAC,SAAD,WAC/C,MAASL,EAAGG,EAAE,iBAAiBC,KAAI,SAACC,GAAD,OAAYA,EAAC,SAAD,aAmEnDJ,IAAUK,OAAOC,iBAAiBN,IAAUO,cA1D5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAC5CC,EAAUC,KAAKC,UAAUJ,EAAKZ,MAClC,IAAKY,EAAKZ,KAAL,KAAoBA,IAASc,EAAS,CACzCd,EAAOc,EAGPnB,EAAIsB,MAAMC,MAAQN,EAAKZ,KAAL,MAClBL,EAAIsB,MAAME,OAASP,EAAKZ,KAAL,OAGnB,IACgB,YADZoB,EAAmB,GACvB,GAAIR,EAAKS,OACP,UAAIT,EAAKS,aAAT,aAAI,EAAYC,mBACd3B,EAAIsB,MAAMM,WAAaX,EAAKS,MAAMC,iBAEpCF,EAAY,CAAC,CACXI,SAAU,gBACVP,MAAO,CACLK,gBAAe,UAAEV,EAAKS,aAAP,aAAE,EAAYI,eAE9B,CACDD,SAAU,OACVP,MAAO,CACLS,MAAK,UAAEd,EAAKS,aAAP,aAAE,EAAYM,UACnBC,WAAU,UAAEhB,EAAKS,aAAP,aAAE,EAAYQ,OAEzB,CACDL,SAAU,gBACVP,MAAO,CACLa,iBAAgB,UAAElB,EAAKS,aAAP,aAAE,EAAYI,aAC9BM,UAAS,UAAEnB,EAAKS,aAAP,aAAE,EAAYI,gBAM7B,IAAIvB,EAAKZ,IAAU,CACjB0C,UAAWrC,EACXsC,SAAUrB,EAAKZ,KAAL,SACViB,MAAOL,EAAKZ,KAAL,WAAwBkC,OAAOd,GACtCe,OAAQvB,EAAKZ,KAAL,OACRoC,cAAexB,EAAKZ,KAAL,cACfqC,mBAAoBzB,EAAKZ,KAAL,mBACpBsC,mBAAoB1B,EAAKZ,KAAL,mBACpBuC,QAAS3B,EAAKZ,KAAL,QACTwC,QAAS5B,EAAKZ,KAAL,UACRyC,GAAG,mBAAmB,WACvBxC,EAAgBC,MAElBD,EAAgBC,GAGlBC,IAAUuC,oBAQZvC,IAAUwC,oBAIVxC,IAAUuC,mB","file":"static/js/main.6a3cf10d.chunk.js","sourcesContent":["import {\n  Streamlit,\n  RenderData\n} from \"streamlit-component-lib\"\n// @ts-ignore\nimport cytoscape from 'cytoscape';\n// @ts-ignore\nimport fcose from 'cytoscape-fcose';\n// @ts-ignore\nimport klay from 'cytoscape-klay';\n// @ts-ignore\nimport dagre from 'cytoscape-dagre';\n\ncytoscape.use(fcose);\ncytoscape.use(klay);\ncytoscape.use(dagre);\n\nconst div = document.body.appendChild(document.createElement(\"div\"));\nlet args = '';\n\nfunction updateComponent(cy: any) {\n  Streamlit.setComponentValue({\n    'nodes': cy.$('node:selected').map((x: any) => x['_private']['data']['id']),\n    'edges': cy.$('edge:selected').map((x: any) => x['_private']['data']['id'])\n  })\n}\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n  let newArgs = JSON.stringify(data.args);\n  if (!data.args[\"key\"] || args !== newArgs) {\n    args = newArgs;\n\n    // Update the dimension of the graph's container\n    div.style.width = data.args[\"width\"];\n    div.style.height = data.args[\"height\"];\n\n    // Take into account the Streamlit theme\n    let nodeColor: any[] = [];\n    if (data.theme) {\n      if (data.theme?.backgroundColor) {\n        div.style.background = data.theme.backgroundColor;\n      }\n      nodeColor = [{\n        selector: \"node:selected\",\n        style: {\n          backgroundColor: data.theme?.primaryColor\n        }\n      }, {\n        selector: \"node\",\n        style: {\n          color: data.theme?.textColor,\n          fontFamily: data.theme?.font\n        }\n      }, {\n        selector: \"edge:selected\",\n        style: {\n          targetArrowColor: data.theme?.primaryColor,\n          lineColor: data.theme?.primaryColor\n        }\n      }]\n    }\n\n    //Create the Cytoscape Graph\n    let cy = cytoscape({\n      container: div,\n      elements: data.args[\"elements\"],\n      style: data.args[\"stylesheet\"].concat(nodeColor),\n      layout: data.args[\"layout\"],\n      selectionType: data.args[\"selectionType\"],\n      userZoomingEnabled: data.args[\"userZoomingEnabled\"],\n      userPanningEnabled: data.args[\"userPanningEnabled\"],\n      minZoom: data.args[\"minZoom\"],\n      maxZoom: data.args[\"maxZoom\"],\n    }).on('select unselect', function () {\n      updateComponent(cy);\n    });\n    updateComponent(cy);\n  }\n\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}